# 2024-04-18
# Amazon Web Services has n servers where the ith server's vulnerability score is vulnerability[i]. A client wants to
# deploy their application on a group of m contiguous servers. The vulnerability of a group is defined as the kth
# minimum vulnerability among the chosen servers. Find the vulnerability of each possible group of m contiguous
# servers the client can choose.
#
# Function Description
#
# Complete the function findKthMinimumVulnerability in the editor below.
#
# findKthMinimumVulnerability has the following parameter(s):
#
# int k: the order of the vulnerability to find
# int m: the number of servers in a group
# int vulnerability[n]: the vulnerabilities of each server
# Returns
#
# int[]: the vulnerabilities for each group, in order
import heapq
from collections import Counter
from typing import List


class Solution:
    def findKthMinimumVulnerability(self, k: int, m: int, vulnerability: List[int]) -> List[int]:
        """
        Time O(n * log(m))
        Space O(m)
        对于n个数，每次我们需要log(m)操作加入或者弹出优先列队。
        此题灵感来源于480，依旧是构造大顶堆和小顶堆来找中位数的逻辑，只是这里不是中位数是第k个数。之后的逻辑和480基本一样，
        区别是，这里的第k个最小的数就是大顶堆的堆顶元素。

        先初始化，之后就已经达到大顶堆k个数，小顶堆m - k 个数的平衡，如何判断后续两个堆是否平衡，这里我们用一个参数balance来track
        如果当前要移动出去的数字在大顶堆内，或者当前加入的新数字去小顶堆，此时 balance -= 1。
        如果当前要移动出去的数字在小顶堆内，或者当前加入的新数字去大顶堆，此时 balance += 1。
        balance对应三种状态：
        balance = 0: 两个堆达到平衡，不需要什么操作。
        balance < 0: 大顶堆需要更多的元素。弹出小顶堆最小值去加入进大顶堆。
        balance > 0: 小顶堆需要更多的元素。弹出大顶堆最大值去加入进小顶堆。
        对于要移除的数字，我们采用lazy removal的方式，也就是我们持续记录要移除的数字的频率。
        如果大顶堆的最大值在要移除的字典内，说明大顶堆头结点需要改变也就是此时的第k个数有变化，移除大顶堆头结点。
        同理对于小顶堆。但是如果要移除数不在两个堆的头结点，我们什么操作都不执行，留在堆内，
        因为前面判断过是否平衡的操作，即使留在堆内，也不影响第k个数的选择。
        """
        max_heap = []  # store the smaller k numbers
        min_heap = []  # store the rest of number
        to_remove = Counter()  # {int to remove: count}
        # 第一个窗口先进大顶堆
        for i in range(m):
            heapq.heappush(max_heap, -vulnerability[i])

        # 平衡大顶堆和小顶堆，大于k个的数进入小顶堆，保证第k个最小的数就是大顶堆的堆顶
        for i in range(m - k):
            heapq.heappush(min_heap, -heapq.heappop(max_heap))

        # 提取第一个窗口中的第k个最小的数，注意这里Python里面的大顶堆，需要取负数
        res = [-max_heap[0]]

        for i in range(m, len(vulnerability)):
            # 平衡参数
            balance = 0
            # 出去的数
            out_num = vulnerability[i - m]
            # 进来的数
            in_num = vulnerability[i]
            # 记录出去的数的频率
            to_remove[out_num] += 1

            # 更新平衡参数通过查看移除的数在那一边
            balance += -1 if max_heap and out_num <= -max_heap[0] else 1

            # 如果进来的数在大顶堆
            if max_heap and in_num <= -max_heap[0]:
                heapq.heappush(max_heap, -in_num)
                balance += 1
            # 如果进来的在小顶堆
            else:
                heapq.heappush(min_heap, in_num)
                balance -= 1

            # 移除弹出的数和添加新的数之后，需要需要回到初始化的平衡状态，
            # 大顶堆多于小顶堆
            if balance > 0:
                heapq.heappush(min_heap, -heapq.heappop(max_heap))
            # 相反
            if balance < 0:
                heapq.heappush(max_heap, -heapq.heappop(min_heap))

            # 查看移除的数在哪一边，同时更新，大顶堆堆顶是需要移除的数
            while max_heap and to_remove[-max_heap[0]]:
                to_remove[-heapq.heappop(max_heap)] -= 1
            # 小顶堆堆顶是需要移除的数
            while min_heap and to_remove[min_heap[0]]:
                to_remove[heapq.heappop(min_heap)] -= 1

            # 提取新的中位数
            res.append(-max_heap[0])

        return res


s = Solution()
print(s.findKthMinimumVulnerability(k=2, m=3, vulnerability=[1, 3, 2, 1]))
print(s.findKthMinimumVulnerability(k=3, m=4, vulnerability=[4, 2, 3, 1, 1]))
